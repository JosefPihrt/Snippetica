{
  " const": {
    "prefix": "k",
    "body": [
      "const ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": " const declaration"
  },
  " function": {
    "prefix": "f",
    "body": [
      "${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": " function declaration"
  },
  " function (with parameters)": {
    "prefix": "f_",
    "body": [
      "${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": " function declaration (with parameters)"
  },
  "#define": {
    "prefix": "ppd",
    "body": [
      "#define ${1:x}${0}"
    ],
    "description": "#define preprocessor directive"
  },
  "#error": {
    "prefix": "ppe",
    "body": [
      "#error ${1:message}${TM_SELECTED_TEXT}${0}"
    ],
    "description": "#error preprocessor directive"
  },
  "#if": {
    "prefix": "ppif",
    "body": [
      "#if ${1:x}",
      "\t${TM_SELECTED_TEXT}${0}",
      "#endif"
    ],
    "description": "#if preprocessor directive"
  },
  "#if #else": {
    "prefix": "ppife",
    "body": [
      "#if ${1:x}",
      "\t${TM_SELECTED_TEXT}${0}",
      "#elif ${2:x}",
      "#else",
      "#endif"
    ],
    "description": "#if #else preprocessor directive"
  },
  "#ifdef": {
    "prefix": "ppifd",
    "body": [
      "#ifdef ${1:x}",
      "\t${TM_SELECTED_TEXT}${0}",
      "#endif"
    ],
    "description": "#ifdef preprocessor directive"
  },
  "#ifndef": {
    "prefix": "ppifnd",
    "body": [
      "#ifndef ${1:x}",
      "\t${TM_SELECTED_TEXT}${0}",
      "#endif"
    ],
    "description": "#ifndef preprocessor directive"
  },
  "#include": {
    "prefix": "ppi",
    "body": [
      "#include <${1:path}${TM_SELECTED_TEXT}>${0}"
    ],
    "description": "#include preprocessor directive"
  },
  "#line": {
    "prefix": "ppl",
    "body": [
      "#line ${1:0} ${2:file}${0}"
    ],
    "description": "#line preprocessor directive"
  },
  "#pragma region": {
    "prefix": "ppr",
    "body": [
      "#pragma region ${1:RegionName}",
      "\t${TM_SELECTED_TEXT}${0}",
      "#pragma endregion ${1}"
    ],
    "description": "#pragma region preprocessor directive"
  },
  "#undef": {
    "prefix": "ppud",
    "body": [
      "#undef ${1:x}${0}"
    ],
    "description": "#undef preprocessor directive"
  },
  "#using": {
    "prefix": "ppu",
    "body": [
      "#using ${1:file}${0}"
    ],
    "description": "#using preprocessor directive"
  },
  "alignas keyword": {
    "prefix": "aa",
    "body": [
      "alignas${0}"
    ],
    "description": "alignas keyword"
  },
  "alignof keyword": {
    "prefix": "ao",
    "body": [
      "alignof${0}"
    ],
    "description": "alignof keyword"
  },
  "array variable": {
    "prefix": "va",
    "body": [
      "${1:T} ${2:items}[${3:0}];${0}"
    ],
    "description": "array variable declaration"
  },
  "array variable (with initializer)": {
    "prefix": "va_",
    "body": [
      "${1:T} ${2:items}[] = { ${3:nullptr} };${0}"
    ],
    "description": "array variable declaration (with initializer)"
  },
  "attribute": {
    "prefix": "ae",
    "body": [
      "[[${1:attribute}${TM_SELECTED_TEXT}]]${0}"
    ],
    "description": "attribute"
  },
  "auto keyword": {
    "prefix": "a",
    "body": [
      "auto${0}"
    ],
    "description": "auto keyword"
  },
  "Boolean variable": {
    "prefix": "vb",
    "body": [
      "bool ${1:f} = ${2:false};${0}"
    ],
    "description": "Boolean variable declaration"
  },
  "braces": {
    "prefix": "b",
    "body": [
      "{",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "braces"
  },
  "break statement": {
    "prefix": "bk",
    "body": [
      "break;${0}"
    ],
    "description": "break statement"
  },
  "catch": {
    "prefix": "catch",
    "body": [
      "catch (const ${1:std::exception}& ${2:e}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "catch clause"
  },
  "class": {
    "prefix": "c",
    "body": [
      "class ${1:ClassName} {",
      "public:",
      "\t${1}();",
      "\t~${1}();",
      "",
      "private:",
      "\t${TM_SELECTED_TEXT}${0}",
      "};",
      "",
      "${1}::${1}() {",
      "}",
      "",
      "${1}::~${1}() {",
      "}"
    ],
    "description": "class declaration"
  },
  "Class with Inline Constructor/Destructor": {
    "prefix": "ci",
    "body": [
      "class ${1:ClassName} {",
      "public:",
      "\t${1}() {",
      "\t}",
      "",
      "\t~${1}() {",
      "\t}",
      "",
      "private:",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "Class declaration with inline constructor/destructor"
  },
  "const cast": {
    "prefix": "coc",
    "body": [
      "const_cast<${1:T}>(${2:expression})${0}"
    ],
    "description": "const cast"
  },
  "const class": {
    "prefix": "kc",
    "body": [
      "",
      "      const class ${1:ClassName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "const class declaration"
  },
  "const function": {
    "prefix": "kf",
    "body": [
      "const ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "const function declaration"
  },
  "const function (with parameters)": {
    "prefix": "kf_",
    "body": [
      "const ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "const function declaration (with parameters)"
  },
  "const struct": {
    "prefix": "kst",
    "body": [
      "const struct ${1:StructName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "const struct declaration"
  },
  "constexpr function": {
    "prefix": "kef",
    "body": [
      "constexpr ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "constexpr function declaration"
  },
  "constexpr function (with parameters)": {
    "prefix": "kef_",
    "body": [
      "constexpr ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "constexpr function declaration (with parameters)"
  },
  "constructor (with parameters)": {
    "prefix": "cr_",
    "body": [
      "${1:TypeName}(${2:T parameter}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "constructor declaration (with parameters)"
  },
  "continue statement": {
    "prefix": "ce",
    "body": [
      "continue;${0}"
    ],
    "description": "continue statement"
  },
  "copy assignment operator": {
    "prefix": "o_ca",
    "body": [
      "${1:TypeName}& operator=(${1} ${2:other}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "\treturn *this;",
      "}"
    ],
    "description": "copy assignment operator"
  },
  "copy assignment operator 2": {
    "prefix": "o_ca2",
    "body": [
      "${1:TypeName}& operator=(const ${1}& ${2:other}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "\treturn *this;",
      "}"
    ],
    "description": "copy assignment operator 2"
  },
  "copy constructor": {
    "prefix": "ccr",
    "body": [
      "",
      "      ${1:TypeName}(const ${1}& ${2:x}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "copy constructor"
  },
  "decltype keyword": {
    "prefix": "dt",
    "body": [
      "decltype${0}"
    ],
    "description": "decltype keyword"
  },
  "default keyword": {
    "prefix": "d",
    "body": [
      "default${0}"
    ],
    "description": "default keyword"
  },
  "delete keyword": {
    "prefix": "de",
    "body": [
      "delete${0}"
    ],
    "description": "delete keyword"
  },
  "destructor": {
    "prefix": "dr",
    "body": [
      "~${1:TypeName}() {",
      "\t${0}",
      "}"
    ],
    "description": "destructor declaration"
  },
  "do-while": {
    "prefix": "dw",
    "body": [
      "do {",
      "\t${TM_SELECTED_TEXT}${0}",
      "} while (${1:true});"
    ],
    "description": "do-while statement"
  },
  "dynamic cast": {
    "prefix": "cod",
    "body": [
      "dynamic_cast<${1:T}>(${2:expression})${0}"
    ],
    "description": "dynamic cast"
  },
  "else": {
    "prefix": "e",
    "body": [
      "else {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "else statement"
  },
  "else-if": {
    "prefix": "eif",
    "body": [
      "else if (${1:true}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "else-if"
  },
  "enum": {
    "prefix": "em",
    "body": [
      "enum ${1:EnumName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "enum declaration"
  },
  "enum class": {
    "prefix": "emc",
    "body": [
      "enum class ${1:EnumClassName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "enum class declaration"
  },
  "extern keyword": {
    "prefix": "en",
    "body": [
      "extern${0}"
    ],
    "description": "extern keyword"
  },
  "for": {
    "prefix": "fr",
    "body": [
      "for (${1:size_t} ${2:i} = 0; ${2} < ${3:length}; ${2}++) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "for statement"
  },
  "for (range-based)": {
    "prefix": "frrb",
    "body": [
      "for (auto& ${1:i} : ${2:x}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "range-based for statement"
  },
  "for (reversed)": {
    "prefix": "frr",
    "body": [
      "for (int ${1:i} = ${2:length} - 1; ${1} >= 0; ${1}--) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "for statement (reversed)"
  },
  "friend keyword": {
    "prefix": "fd",
    "body": [
      "friend${0}"
    ],
    "description": "friend keyword"
  },
  "if": {
    "prefix": "if",
    "body": [
      "if (${1:true}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "if statement"
  },
  "if constexpr": {
    "prefix": "ifke",
    "body": [
      "if constexpr (${1:true}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "if constexpr statement"
  },
  "inline const function": {
    "prefix": "ilkf",
    "body": [
      "inline const ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "inline const function declaration"
  },
  "inline const function (with parameters)": {
    "prefix": "ilkf_",
    "body": [
      "inline const ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "inline const function declaration (with parameters)"
  },
  "inline function": {
    "prefix": "ilf",
    "body": [
      "inline ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "inline function declaration"
  },
  "inline function (with parameters)": {
    "prefix": "ilf_",
    "body": [
      "inline ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "inline function declaration (with parameters)"
  },
  "inline namespace": {
    "prefix": "ins",
    "body": [
      "inline namespace ${1:NamespaceName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "inline namespace declaration"
  },
  "Int32 variable": {
    "prefix": "vi",
    "body": [
      "int ${1:i} = ${2:0};${0}"
    ],
    "description": "Int32 variable declaration"
  },
  "interface": {
    "prefix": "ie",
    "body": [
      "__interface ${1:InterfaceName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "interface declaration"
  },
  "lambda expression": {
    "prefix": "l",
    "body": [
      "[${1:&}]() -> ${2:T} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "lambda expression"
  },
  "lambda expression (minimal)": {
    "prefix": "lm",
    "body": [
      "[${1:&}]() {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "lambda expression (minimal)"
  },
  "lambda expression (minimal) (with parameters)": {
    "prefix": "lm_",
    "body": [
      "[${1:&}](${2:T parameter}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "lambda expression (minimal) (with parameters)"
  },
  "lambda expression (with parameters)": {
    "prefix": "l_",
    "body": [
      "[${1:&}](${2:T parameter}) -> ${3:T} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "lambda expression (with parameters)"
  },
  "move assignment operator": {
    "prefix": "op_ma",
    "body": [
      "${1:TypeName}& operator=(${1}&& ${2:other}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "\treturn *this;",
      "}"
    ],
    "description": "move assignment operator"
  },
  "move constructor": {
    "prefix": "mcr",
    "body": [
      "",
      "      ${1:TypeName}(${1}&& ${2:x}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "move constructor"
  },
  "multi-line comment": {
    "prefix": "mc",
    "body": [
      "/*${TM_SELECTED_TEXT}${0}*/"
    ],
    "description": "multi-line comment"
  },
  "namespace": {
    "prefix": "ns",
    "body": [
      "namespace ${1:NamespaceName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "namespace declaration"
  },
  "noexcept keyword": {
    "prefix": "ne",
    "body": [
      "noexcept${0}"
    ],
    "description": "noexcept keyword"
  },
  "nullptr keyword": {
    "prefix": "np",
    "body": [
      "nullptr${0}"
    ],
    "description": "nullptr keyword"
  },
  "operator keyword": {
    "prefix": "or",
    "body": [
      "operator${0}"
    ],
    "description": "operator keyword"
  },
  "reinterpret cast": {
    "prefix": "cor",
    "body": [
      "reinterpret_cast<${1:T}>(${2:expression})${0}"
    ],
    "description": "reinterpret cast"
  },
  "return false": {
    "prefix": "ref",
    "body": [
      "return false;${0}"
    ],
    "description": "return false"
  },
  "return keyword": {
    "prefix": "r",
    "body": [
      "return${0}"
    ],
    "description": "return keyword"
  },
  "return statement": {
    "prefix": "re",
    "body": [
      "return;${0}"
    ],
    "description": "return statement"
  },
  "return true": {
    "prefix": "ret",
    "body": [
      "return true;${0}"
    ],
    "description": "return true"
  },
  "sizeof keyword": {
    "prefix": "so",
    "body": [
      "sizeof${0}"
    ],
    "description": "sizeof keyword"
  },
  "static assert": {
    "prefix": "sa",
    "body": [
      "static_assert(${1:expression}${TM_SELECTED_TEXT})${0}"
    ],
    "description": "static assert"
  },
  "static cast": {
    "prefix": "cos",
    "body": [
      "static_cast<${1:T}>(${2:expression})${0}"
    ],
    "description": "static cast"
  },
  "static const": {
    "prefix": "sk",
    "body": [
      "static const ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": "static const declaration"
  },
  "static const function": {
    "prefix": "skf",
    "body": [
      "static const ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "static const function declaration"
  },
  "static const function (with parameters)": {
    "prefix": "skf_",
    "body": [
      "static const ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "static const function declaration (with parameters)"
  },
  "static const variable declaration": {
    "prefix": "skv",
    "body": [
      "static const ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": "static const  variable declaration"
  },
  "static constexpr function": {
    "prefix": "skef",
    "body": [
      "static constexpr ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "static constexpr function declaration"
  },
  "static constexpr function (with parameters)": {
    "prefix": "skef_",
    "body": [
      "static constexpr ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "static constexpr function declaration (with parameters)"
  },
  "static constexpr variable declaration": {
    "prefix": "skev",
    "body": [
      "static constexpr ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": "static constexpr  variable declaration"
  },
  "static function": {
    "prefix": "sf",
    "body": [
      "static ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "static function declaration"
  },
  "static function (with parameters)": {
    "prefix": "sf_",
    "body": [
      "static ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "static function declaration (with parameters)"
  },
  "static inline const function": {
    "prefix": "silkf",
    "body": [
      "static inline const ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "static inline const function declaration"
  },
  "static inline const function (with parameters)": {
    "prefix": "silkf_",
    "body": [
      "static inline const ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "static inline const function declaration (with parameters)"
  },
  "static inline const variable declaration": {
    "prefix": "silkv",
    "body": [
      "static inline const ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": "static inline const  variable declaration"
  },
  "static inline function": {
    "prefix": "silf",
    "body": [
      "static inline ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "static inline function declaration"
  },
  "static inline function (with parameters)": {
    "prefix": "silf_",
    "body": [
      "static inline ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "static inline function declaration (with parameters)"
  },
  "static inline variable declaration": {
    "prefix": "silv",
    "body": [
      "static inline ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": "static inline  variable declaration"
  },
  "static variable declaration": {
    "prefix": "sv",
    "body": [
      "static ${1:T} ${2:x} = ${3:nullptr};${0}"
    ],
    "description": "static  variable declaration"
  },
  "string type": {
    "prefix": "s",
    "body": [
      "std::string${0}"
    ],
    "description": "string type"
  },
  "String variable": {
    "prefix": "vs",
    "body": [
      "std::string ${1:s} = ${2:nullptr};${0}"
    ],
    "description": "String variable declaration"
  },
  "struct": {
    "prefix": "st",
    "body": [
      "struct ${1:StructName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "struct declaration"
  },
  "switch": {
    "prefix": "sh",
    "body": [
      "switch (${1:SwitchOn}) {",
      "\t${2:default:",
      "    break;}${0}",
      "}"
    ],
    "description": "switch statement"
  },
  "template": {
    "prefix": "t",
    "body": [
      "template <${1:typename} ${2:T}>${0}"
    ],
    "description": "template"
  },
  "template with 2 parameters": {
    "prefix": "t2",
    "body": [
      "template <${1:typename} ${2:T}, ${3:typename} ${4:T2}>${0}"
    ],
    "description": "template with 2 parameters"
  },
  "thread_local keyword": {
    "prefix": "tl",
    "body": [
      "thread_local${0}"
    ],
    "description": "thread_local keyword"
  },
  "throw keyword": {
    "prefix": "tw",
    "body": [
      "throw${0}"
    ],
    "description": "throw keyword"
  },
  "try-catch": {
    "prefix": "tc",
    "body": [
      "try {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}",
      "catch (const ${1:std::exception}& ${2:e}) {",
      "}"
    ],
    "description": "try-catch"
  },
  "typedef keyword": {
    "prefix": "td",
    "body": [
      "typedef${0}"
    ],
    "description": "typedef keyword"
  },
  "typeid keyword": {
    "prefix": "ti",
    "body": [
      "typeid${0}"
    ],
    "description": "typeid keyword"
  },
  "typename keyword": {
    "prefix": "tn",
    "body": [
      "typename${0}"
    ],
    "description": "typename keyword"
  },
  "union": {
    "prefix": "un",
    "body": [
      "union ${1:UnionName} {",
      "\t${TM_SELECTED_TEXT}${0}",
      "};"
    ],
    "description": "union"
  },
  "unsigned keyword": {
    "prefix": "us",
    "body": [
      "unsigned${0}"
    ],
    "description": "unsigned keyword"
  },
  "using declaration": {
    "prefix": "u",
    "body": [
      "using ${1:NamespaceName}::${2:Name};${0}"
    ],
    "description": "using declaration"
  },
  "using namespace": {
    "prefix": "uns",
    "body": [
      "using namespace ${1:NamespaceName}${TM_SELECTED_TEXT};${0}"
    ],
    "description": "using namespace"
  },
  "virtual function": {
    "prefix": "vf",
    "body": [
      "virtual ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "virtual function declaration"
  },
  "virtual function (with parameters)": {
    "prefix": "vf_",
    "body": [
      "virtual ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "virtual function declaration (with parameters)"
  },
  "virtual inline function": {
    "prefix": "vilf",
    "body": [
      "virtual inline ${1:void} ${2:FunctionName}() {",
      "\t${0}",
      "}"
    ],
    "description": "virtual inline function declaration"
  },
  "virtual inline function (with parameters)": {
    "prefix": "vilf_",
    "body": [
      "virtual inline ${1:void} ${2:FunctionName}(${3:T parameter}) {",
      "\t${0}",
      "}"
    ],
    "description": "virtual inline function declaration (with parameters)"
  },
  "volatile keyword": {
    "prefix": "ve",
    "body": [
      "volatile${0}"
    ],
    "description": "volatile keyword"
  },
  "while": {
    "prefix": "we",
    "body": [
      "while (${1:true}) {",
      "\t${TM_SELECTED_TEXT}${0}",
      "}"
    ],
    "description": "while statement"
  }
}